<script lang="ts">
  import type { PageData } from './$types';
  import { Product } from '$lib/stores/product';
  import ProductCard from '$lib/components/ProductCard.svelte';
  import EditProductCard from '$lib/components/EditProductCard.svelte';
  import { updateProduct, createProduct, deleteProduct, reactivateProduct, swapProductOrder, getAllProducts } from '$lib/services/products';
  
  export let data: PageData;
  
  // State management - convert plain objects to Product instances
  let products: Product[] = data.products.map((p: any) => new Product(p));
  let editingIndex: number | null = null; // Track which product is being edited
  let isCreating = false; // Track if we're creating a new product
  let showInactive = true; // Toggle to show/hide inactive products
  
  // Computed filtered products
  $: filteredProducts = showInactive 
    ? products 
    : products.filter(p => p.isActive);
  
  function handleEdit(product: Product) {
    editingIndex = products.findIndex(p => p.id === product.id);
    isCreating = false;
  }
  
  async function handleSave(product: Product, updatedProduct: Product) {
    const index = products.findIndex(p => p.id === product.id);
    try {
      // Convert Product to database format
      const productData = {
        id: updatedProduct.id,
        name: updatedProduct.name,
        description: updatedProduct.description,
        image_path: updatedProduct.imagePath,
        featured: updatedProduct.featured,
        price_cents: updatedProduct.priceCents,
        is_active: updatedProduct.isActive
      };
      
      if (isCreating) {
        // Remove id for new products - Supabase will auto-generate
        const { id, ...newProductData } = productData;
        const result = await createProduct(newProductData);
        if (result && result[0]) {
          // Add the new product to our list with the generated ID
          const newProduct = new Product(result[0]);
          // Remove the placeholder and add the real product
          products = products.slice(0, -1);
          products = [...products, newProduct];
        }
      } else {
        // Update existing product
        await updateProduct(productData);
        products[index] = updatedProduct;
        // Force reactivity update
        products = [...products];
      }
      
      editingIndex = null;
      isCreating = false;
    } catch (error) {
      console.error('Error saving product:', error);
      alert('Failed to save product. Please try again.');
    }
  }
  
  function handleCancel() {
    if (isCreating) {
      // Remove the placeholder product we added for creation
      products = products.slice(0, -1);
    }
    editingIndex = null;
    isCreating = false;
  }
  
  function handleCreate() {
    // Create a placeholder product for editing
    const newProduct = new Product({
      id: '', // Will be generated by database
      name: 'New Product',
      description: 'Product description',
      image_path: '',
      featured: false,
      price_cents: 1200, // Default $12.00
      is_active: true,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    });
    
    products = [...products, newProduct];
    editingIndex = products.length - 1;
    isCreating = true;
  }
  
  async function handleDelete(product: Product) {
    if (confirm(`Are you sure you want to deactivate "${product.name}"? It will be hidden from customers.`)) {
      try {
        await deleteProduct(product.id);
        // Update the product in our local state to reflect it's now inactive
        const index = products.findIndex(p => p.id === product.id);
        if (index !== -1) {
          products[index].isActive = false;
          products = [...products]; // Trigger reactivity
        }
        if (editingIndex === index) {
          editingIndex = null;
          isCreating = false;
        }
      } catch (error) {
        console.error('Error deactivating product:', error);
        alert('Failed to deactivate product. Please try again.');
      }
    }
  }
  
  async function handleReactivate(product: Product) {
    if (confirm(`Are you sure you want to reactivate "${product.name}"? It will be visible to customers again.`)) {
      try {
        await reactivateProduct(product.id);
        // Update the product in our local state to reflect it's now active
        const index = products.findIndex(p => p.id === product.id);
        if (index !== -1) {
          products[index].isActive = true;
          products = [...products]; // Trigger reactivity
        }
      } catch (error) {
        console.error('Error reactivating product:', error);
        alert('Failed to reactivate product. Please try again.');
      }
    }
  }
  
  async function handleMoveUp(product: Product) {
    try {
      const currentIndex = products.findIndex(p => p.id === product.id);
      if (currentIndex <= 0) return; // Already at the top
      
      const previousProduct = products[currentIndex - 1];
      
      // Swap the sort orders in the database
      await swapProductOrder(product.id, previousProduct.id);
      
      // Update local state by swapping positions
      const tempSortOrder = products[currentIndex].sortOrder;
      products[currentIndex].sortOrder = products[currentIndex - 1].sortOrder;
      products[currentIndex - 1].sortOrder = tempSortOrder;
      
      // Swap the products in the array
      [products[currentIndex], products[currentIndex - 1]] = [products[currentIndex - 1], products[currentIndex]];
      
      // Trigger reactivity
      products = [...products];
    } catch (error) {
      console.error('Error moving product up:', error);
      alert('Failed to move product. Please try again.');
      // Refresh products from server to ensure consistency
      await refreshProducts();
    }
  }
  
  async function handleMoveDown(product: Product) {
    try {
      const currentIndex = products.findIndex(p => p.id === product.id);
      if (currentIndex >= products.length - 1) return; // Already at the bottom
      
      const nextProduct = products[currentIndex + 1];
      
      // Swap the sort orders in the database
      await swapProductOrder(product.id, nextProduct.id);
      
      // Update local state by swapping positions
      const tempSortOrder = products[currentIndex].sortOrder;
      products[currentIndex].sortOrder = products[currentIndex + 1].sortOrder;
      products[currentIndex + 1].sortOrder = tempSortOrder;
      
      // Swap the products in the array
      [products[currentIndex], products[currentIndex + 1]] = [products[currentIndex + 1], products[currentIndex]];
      
      // Trigger reactivity
      products = [...products];
    } catch (error) {
      console.error('Error moving product down:', error);
      alert('Failed to move product. Please try again.');
      // Refresh products from server to ensure consistency
      await refreshProducts();
    }
  }
  
  async function refreshProducts() {
    try {
      const refreshedProducts = await getAllProducts();
      products = refreshedProducts.map((p: any) => new Product(p));
    } catch (error) {
      console.error('Error refreshing products:', error);
    }
  }
</script>

<div class="max-w-7xl mx-auto px-4 lg:px-8 py-8">
  <!-- Page Header -->
  <div class="mb-8">
    <div class="flex justify-between items-center mb-4">
      <div>
        <h1 class="text-3xl font-bold text-black mb-2">Product Management</h1>
        <p class="text-black">Manage your product offerings and visibility</p>
      </div>
      <button 
        onclick={handleCreate}
        class="bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-medium py-2 px-4 rounded-lg transition-colors duration-200"
      >
        + Add New Product
      </button>
    </div>
    
    <!-- Filter Toggle -->
    <div class="flex items-center gap-2 bg-neutral-100 p-4 rounded-lg border border-gray-200">
      <input 
        id="showInactive"
        type="checkbox" 
        bind:checked={showInactive}
        class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
      />
      <label for="showInactive" class="text-sm font-medium text-gray-700">
        Show inactive products
      </label>
      <span class="text-xs text-gray-500 ml-2">
        ({filteredProducts.length} of {products.length} products shown)
      </span>
    </div>
  </div>

  <!-- Products Grid -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
    {#each filteredProducts as product, index}
      {@const isEditing = editingIndex !== null && products[editingIndex]?.id === product.id}
      {@const actualIndex = products.findIndex(p => p.id === product.id)}
      {@const canMoveUp = actualIndex > 0}
      {@const canMoveDown = actualIndex < products.length - 1}
      {#if isEditing}
        <EditProductCard 
          product={product} 
          onSave={(updatedProduct) => handleSave(product, updatedProduct)}
          onCancel={handleCancel}
        />
      {:else}
        <ProductCard 
          product={product}
          position={actualIndex + 1}
          onEdit={() => handleEdit(product)}
          onDelete={() => handleDelete(product)}
          onReactivate={() => handleReactivate(product)}
          onMoveUp={() => handleMoveUp(product)}
          onMoveDown={() => handleMoveDown(product)}
          canMoveUp={canMoveUp}
          canMoveDown={canMoveDown}
          isAdmin={true}
        />
      {/if}
    {/each}
  </div>
</div>